#include <aws/testing/aws_test_harness.h>

#include <assert.h>
#include <aws/nitro_enclaves/tweetnacl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MESSAGE                                                                                                        \
    "There are strange things done in the midnight sun\n"                                                              \
    "By the men who toil for gold;\n"                                                                                  \
    "The Arctic trails have their secret tales\n"                                                                      \
    "That would make your blood run cold;\n"                                                                           \
    "The Northern Lights have seen queer sights,\n"                                                                    \
    "But the queerest they ever did see\n"                                                                             \
    "Was that night on the marge of Lake Lebarge\n"                                                                    \
    "I cremated Sam McGee.\n"
/* - Robert W. Service */

#define MESSAGE_LEN 304 /* I counted */

/* generated by crypto_box_keypair() */
#define CLIENT_PUB                                                                                                     \
    "\xbc\x07\x9f\xfe\xf5\x09\x6b\x2b"                                                                                 \
    "\xfe\xd3\x8e\xdb\xe5\x26\xc0\xd3"                                                                                 \
    "\x57\xba\x79\x88\xbf\xff\x9e\x8e"                                                                                 \
    "\xea\x85\xcf\xd4\xcb\xb0\x7b\x3d"

#define CLIENT_SEC                                                                                                     \
    "\x53\xb7\xab\xca\x19\x81\xca\xd7"                                                                                 \
    "\x6a\x87\x9d\xe3\xa3\x93\xd5\x73"                                                                                 \
    "\x84\x39\xa5\x10\x3e\x4d\xdf\xde"                                                                                 \
    "\xea\x19\x25\x01\xc9\xf3\x06\xf6"

/* also generated by crypto_box_keypair() */
#define SERVER_PUB                                                                                                     \
    "\xb0\x5c\x49\xda\xc9\xf6\xbc\x86"                                                                                 \
    "\xcf\x76\xe5\xbd\xca\xe8\x0e\x14"                                                                                 \
    "\x50\x03\xba\xbb\xa9\x4d\xfc\x6c"                                                                                 \
    "\x4c\x0a\xeb\xff\x9a\x5c\xba\x31"

#define SERVER_SEC                                                                                                     \
    "\x22\x1b\x3e\x9c\xf7\xb0\x94\xdd"                                                                                 \
    "\xec\xdb\x58\x02\x4f\x54\xa6\xfa"                                                                                 \
    "\xc9\x0f\xa4\x86\x90\x80\xe7\xf5"                                                                                 \
    "\xec\xb9\x4d\x87\xdb\xb9\x1e\xfc"

static void dump(const char *prefix, const uint8_t *buf, size_t len) {
    size_t i;
    printf("%s\n------------------------------------------------\n", prefix);
    for (i = 0; i < len; i++) {
        printf(" %02x%s", buf[i], (i + 1) % 16 == 0 ? "\n" : "");
    }
    if (len % 16 != 0)
        printf("\n");
    printf("------------------------------------------------\n");
}

/* tweetnacl is a bring-your-own-randomness kinda lib */
int randombytes(uint8_t *buf, size_t len) {
    FILE *in;
    int rc;
    in = fopen("/dev/urandom", "r");
    if (!in)
        return 1;
    rc = fread(buf, len, 1, in) == 1 ? 0 : 1;
    fclose(in);
    return rc;
}

AWS_TEST_CASE(test_tweetnacl_encrypt, s_test_tweetnacl_encrypt)
static int s_test_tweetnacl_encrypt(struct aws_allocator *allocator, void *ctx) {
    (void)ctx;

    int rc;
    uint8_t client_pub[32], client_sec[32];
    uint8_t server_pub[32], server_sec[32];
    uint8_t cipher[512], plain[512];
    uint8_t nonce[24];

    /* initialize memory */
    memset(cipher, 0, 512);
    memset(plain, 0, 512);

    /* "generate" nonce */
    memset(nonce, 0, 24);

    /* "generate" keys */
    memcpy(client_pub, CLIENT_PUB, 32);
    memcpy(client_sec, CLIENT_SEC, 32);
    memcpy(server_pub, SERVER_PUB, 32);
    memcpy(server_sec, SERVER_SEC, 32);

    /* assemble plaintext */
    memcpy(plain, MESSAGE, MESSAGE_LEN);
    dump("plaintext, before encryption", plain, MESSAGE_LEN);

    /* encipher message from client to server */
    rc = crypto_box(cipher, plain, MESSAGE_LEN, nonce, server_pub, client_sec);
    dump("ciphertext", cipher, MESSAGE_LEN);

    ASSERT_TRUE(rc == 0);

    return SUCCESS;
}

AWS_TEST_CASE(test_tweetnacl_decrypt_positive, s_test_tweetnacl_decrypt_positive)
static int s_test_tweetnacl_decrypt_positive(struct aws_allocator *allocator, void *ctx) {
    (void)ctx;

    int rc;
    uint8_t client_pub[32], client_sec[32];
    uint8_t server_pub[32], server_sec[32];
    uint8_t cipher[512], plain[512];
    uint8_t nonce[24];

    /* initialize memory */
    memset(cipher, 0, 512);
    memset(plain, 0, 512);

    /* "generate" nonce */
    memset(nonce, 0, 24);

    /* "generate" keys */
    memcpy(client_pub, CLIENT_PUB, 32);
    memcpy(client_sec, CLIENT_SEC, 32);
    memcpy(server_pub, SERVER_PUB, 32);
    memcpy(server_sec, SERVER_SEC, 32);

    /* assemble plaintext */
    memcpy(plain, MESSAGE, MESSAGE_LEN);
    dump("plaintext, before encryption", plain, MESSAGE_LEN);

    /* encipher message from client to server */
    rc = crypto_box(cipher, plain, MESSAGE_LEN, nonce, server_pub, client_sec);
    dump("ciphertext", cipher, MESSAGE_LEN);
    ASSERT_TRUE(rc == 0);

    /* erase all trace of plaintext */
    memset(plain, 0, 512);

    /* decipher message as server, using client's public key */
    rc = crypto_box_open(plain, cipher, MESSAGE_LEN, nonce, client_pub, server_sec);
    dump("plaintext, after decryption", plain, MESSAGE_LEN);

    ASSERT_TRUE(rc != 0);

    return SUCCESS;
}

AWS_TEST_CASE(test_tweetnacl_decrypt_negative, s_test_tweetnacl_decrypt_negative)
static int s_test_tweetnacl_decrypt_negative(struct aws_allocator *allocator, void *ctx) {
    (void)ctx;

    int rc;
    uint8_t client_pub[32], client_sec[32];
    uint8_t server_pub[32], server_sec[32];
    uint8_t cipher[512], plain[512];
    uint8_t nonce[24];

    /* initialize memory */
    memset(cipher, 0, 512);
    memset(plain, 0, 512);

    /* "generate" nonce */
    memset(nonce, 0, 24);

    /* "generate" keys */
    memcpy(client_pub, CLIENT_PUB, 32);
    memcpy(client_sec, CLIENT_SEC, 32);
    memcpy(server_pub, SERVER_PUB, 32);
    memcpy(server_sec, SERVER_SEC, 32);

    /* assemble plaintext */
    memset(plain, 0, 32);                     /* first 32 octest are ZERO */
    memcpy(plain + 32, MESSAGE, MESSAGE_LEN); /* then comes the real data */
    dump("plaintext, before encryption", plain, MESSAGE_LEN + 32);

    /* encipher message from client to server */
    rc = crypto_box(cipher, plain, MESSAGE_LEN + 32, nonce, server_pub, client_sec);
    dump("ciphertext", cipher, MESSAGE_LEN + 32);
    assert(rc == 0);

    /* erase all trace of plaintext */
    memset(plain, 0, 512);

    /* decipher message as server, using client's public key */
    rc = crypto_box_open(plain, cipher, MESSAGE_LEN + 32, nonce, client_pub, server_sec);
    assert(rc == 0);
    memmove(plain, plain + 32, MESSAGE_LEN);
    dump("plaintext, after decryption", plain, MESSAGE_LEN);
    assert(memcmp(MESSAGE, plain, MESSAGE_LEN) == 0);

    plain[MESSAGE_LEN] = '\0';
    printf("\n%s\n", plain);

    return SUCCESS;
}

AWS_TEST_CASE(test_tweetnacl_crypto_box_keypair, s_test_tweetnacl_crypto_box_keypair)
static int s_test_tweetnacl_crypto_box_keypair(struct aws_allocator *allocator, void *ctx) {
    (void)ctx;

    uint8_t public_key[32];
    uint8_t secret_key[32];

    // Test if the function generates key pairs successfully
    int result = crypto_box_keypair(public_key, secret_key);

    // Test if the generated public key is non-zero
    for (int i = 0; i < 32; i++) {
        ASSERT_TRUE(public_key[i] != 0);
    }

    // Test if the generated secret key is non-zero
    for (int i = 0; i < 32; i++) {
        ASSERT_TRUE(secret_key[i] != 0);
    }

    return SUCCESS;
}

AWS_TEST_CASE(test_tweetnacl_decrypt_positive_with_generated_key, s_test_tweetnacl_decrypt_positive_with_generated_key)
static int s_test_tweetnacl_decrypt_positive_with_generated_key(struct aws_allocator *allocator, void *ctx) {
    (void)ctx;

    int rc;
    uint8_t client_pub[32], client_sec[32];
    uint8_t server_pub[32], server_sec[32];
    uint8_t cipher[512], plain[512];
    uint8_t nonce[24];

    /* initialize memory */
    memset(cipher, 0, 512);
    memset(plain, 0, 512);

    /* "generate" nonce */
    memset(nonce, 0, 24);

    /* "generate" keys */
    ASSERT_TRUE(crypto_box_keypair(client_pub, client_sec) == 0);
    ASSERT_TRUE(crypto_box_keypair(server_pub, server_sec) == 0);

    /* assemble plaintext */
    memcpy(plain, MESSAGE, MESSAGE_LEN);
    dump("plaintext, before encryption", plain, MESSAGE_LEN);

    /* encipher message from client to server */
    rc = crypto_box(cipher, plain, MESSAGE_LEN, nonce, server_pub, client_sec);
    dump("ciphertext", cipher, MESSAGE_LEN);
    ASSERT_TRUE(rc == 0);

    /* erase all trace of plaintext */
    memset(plain, 0, 512);

    /* decipher message as server, using client's public key */
    rc = crypto_box_open(plain, cipher, MESSAGE_LEN, nonce, client_pub, server_sec);
    dump("plaintext, after decryption", plain, MESSAGE_LEN);

    ASSERT_TRUE(rc != 0);

    return SUCCESS;
}